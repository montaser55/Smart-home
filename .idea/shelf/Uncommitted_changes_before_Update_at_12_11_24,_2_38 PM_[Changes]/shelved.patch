Index: Assignment_2/codes/synthetic_k_3.csv
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>Direction,Packet Size (bytes)\nreceive,0.9727026717486329\nreceive,0.7940026140772034\nreceive,0.7547055942514824\nreceive,0.8065597591066116\nreceive,0.5184255680139698\nreceive,0.21227997728316494\nreceive,0.6592548074356924\nreceive,0.5725730190613217\nsend,0.19382936071044984\nsend,0.02496810777714734\nsend,0.05559256365190117\nsend,0.5766084500860759\nreceive,0.9107537735925078\nreceive,0.17599677611546316\nsend,0.565487536781585\nreceive,0.7554474943448686\nreceive,0.3299283633021515\nreceive,0.8909305698366022\nreceive,0.5239683494742757\nsend,0.11887401187374497\nsend,0.5607853107296022\nreceive,0.9881040742552409\nreceive,0.24086842782425377\nreceive,0.8873508520885406\nreceive,0.5574114463608811\nsend,0.19507728141532665\nsend,0.5026450426656996\nreceive,0.8274820630657286\nreceive,0.02007031171483381\nsend,0.5561865655674827\nreceive,0.7142817645111382\nreceive,0.7676036528089719\nreceive,0.666937491326919\nreceive,0.18878466436037405\nsend,0.032887453699366964\nsend,0.5490562074790698\nreceive,0.8202446638506293\nreceive,0.8708938701761888\nreceive,0.7012268914050079\nreceive,0.6524958698566923\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Assignment_2/codes/synthetic_k_3.csv b/Assignment_2/codes/synthetic_k_3.csv
--- a/Assignment_2/codes/synthetic_k_3.csv	(revision 8954cdcb18b85d90b5abca4334f5004d93e1cc89)
+++ b/Assignment_2/codes/synthetic_k_3.csv	(date 1731417511224)
@@ -1,41 +1,5 @@
 Direction,Packet Size (bytes)
-receive,0.9727026717486329
-receive,0.7940026140772034
-receive,0.7547055942514824
-receive,0.8065597591066116
-receive,0.5184255680139698
-receive,0.21227997728316494
-receive,0.6592548074356924
-receive,0.5725730190613217
-send,0.19382936071044984
-send,0.02496810777714734
-send,0.05559256365190117
-send,0.5766084500860759
-receive,0.9107537735925078
-receive,0.17599677611546316
-send,0.565487536781585
-receive,0.7554474943448686
-receive,0.3299283633021515
-receive,0.8909305698366022
-receive,0.5239683494742757
-send,0.11887401187374497
-send,0.5607853107296022
-receive,0.9881040742552409
-receive,0.24086842782425377
-receive,0.8873508520885406
-receive,0.5574114463608811
-send,0.19507728141532665
-send,0.5026450426656996
-receive,0.8274820630657286
-receive,0.02007031171483381
-send,0.5561865655674827
-receive,0.7142817645111382
-receive,0.7676036528089719
-receive,0.666937491326919
-receive,0.18878466436037405
-send,0.032887453699366964
-send,0.5490562074790698
-receive,0.8202446638506293
-receive,0.8708938701761888
-receive,0.7012268914050079
-receive,0.6524958698566923
+receive,0.8297389876776882
+receive,0.9750917550512417
+receive,0.9107845648447868
+receive,0.7589036843376389
Index: Assignment_2/codes/synthetic_k_5.csv
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>Direction,Packet Size (bytes)\nreceive,0.8975340938174586\nreceive,0.8168266244902335\nreceive,0.9306679137824312\nreceive,0.9302538800449947\nreceive,0.5828169828030662\nreceive,0.06643290316081729\nreceive,0.6220169149537106\nreceive,0.5863273418811888\nsend,0.38286597977328046\nsend,0.243228569460947\nsend,0.0435596634581466\nsend,0.3427553697060776\nreceive,0.9553642865280961\nreceive,0.1593419759785391\nsend,0.5003182335944455\nreceive,0.8845052843466896\nreceive,0.3517097325356563\nreceive,0.754267911031739\nreceive,0.5538336216548416\nsend,0.19815889040719542\nsend,0.5296618135932165\nreceive,0.9760868343353416\nreceive,0.00432707818092376\nreceive,0.9505630261242668\nreceive,0.6855750934136069\nsend,0.2265735701414335\nsend,0.4099067515938967\nreceive,0.7482341663827687\nreceive,0.19331147571124413\nsend,0.5645831162291118\nreceive,0.9864972180310463\nreceive,0.7939211672879082\nreceive,0.6555238155808468\nreceive,0.05999343040003907\nsend,0.10923403517532154\nsend,0.5147784727451202\nreceive,0.72217983501725\nreceive,0.7808389401413585\nreceive,0.9088412349932358\nreceive,0.5985626643535551\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Assignment_2/codes/synthetic_k_5.csv b/Assignment_2/codes/synthetic_k_5.csv
--- a/Assignment_2/codes/synthetic_k_5.csv	(revision 8954cdcb18b85d90b5abca4334f5004d93e1cc89)
+++ b/Assignment_2/codes/synthetic_k_5.csv	(date 1731417511224)
@@ -1,41 +1,5 @@
 Direction,Packet Size (bytes)
-receive,0.8975340938174586
-receive,0.8168266244902335
-receive,0.9306679137824312
-receive,0.9302538800449947
-receive,0.5828169828030662
-receive,0.06643290316081729
-receive,0.6220169149537106
-receive,0.5863273418811888
-send,0.38286597977328046
-send,0.243228569460947
-send,0.0435596634581466
-send,0.3427553697060776
-receive,0.9553642865280961
-receive,0.1593419759785391
-send,0.5003182335944455
-receive,0.8845052843466896
-receive,0.3517097325356563
-receive,0.754267911031739
-receive,0.5538336216548416
-send,0.19815889040719542
-send,0.5296618135932165
-receive,0.9760868343353416
-receive,0.00432707818092376
-receive,0.9505630261242668
-receive,0.6855750934136069
-send,0.2265735701414335
-send,0.4099067515938967
-receive,0.7482341663827687
-receive,0.19331147571124413
-send,0.5645831162291118
-receive,0.9864972180310463
-receive,0.7939211672879082
-receive,0.6555238155808468
-receive,0.05999343040003907
-send,0.10923403517532154
-send,0.5147784727451202
-receive,0.72217983501725
-receive,0.7808389401413585
-receive,0.9088412349932358
-receive,0.5985626643535551
+send,0.27677598541865356
+receive,0.9398625432140519
+receive,0.8128381981209973
+receive,0.9462011176491466
Index: Assignment_2/codes/k_nearest_neighbours.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import numpy as np\nimport random\nimport argparse\n\n\n# Encode direction for categorical handling\ndef encode_direction(direction):\n    return 0 if direction == 'receive' else 1\n\n\ndef decode_direction(encoded_value):\n    return 'receive' if encoded_value == 0 else 'send'\n\n\n# Normalization Functions\ndef min_max_normalization(data):\n    return (data - np.min(data, axis=0)) / (np.max(data, axis=0) - np.min(data, axis=0))\n\n\ndef z_score_normalization(data):\n    return (data - np.mean(data, axis=0)) / np.std(data, axis=0)\n\n\n# Manhattan Distance Calculation\ndef manhattan_distance(sample1, sample2):\n    return np.sum(np.abs(sample1 - sample2))\n\n\n# Function to find k nearest neighbors\ndef find_k_nearest_neighbors(data, sample, k):\n    distances = []\n    for i, other_sample in enumerate(data):\n        if not np.array_equal(sample, other_sample):\n            distances.append((i, manhattan_distance(sample, other_sample)))\n    distances.sort(key=lambda x: x[1])  # Sort by distance\n    return [data[i] for i, _ in distances[:k]]\n\n\n# Synthetic Sample Generation\ndef generate_synthetic_samples(data, k, total_synthetic_samples):\n    synthetic_data = []\n    samples_to_generate = total_synthetic_samples // len(data)  # Evenly distribute synthetic samples across the dataset\n    remaining_samples = total_synthetic_samples % len(data)  # Handle any remaining samples\n    print(total_synthetic_samples, samples_to_generate)\n    for i, sample in enumerate(data):\n         if i < remaining_samples:\n            neighbor = random.choice(find_k_nearest_neighbors(data, sample, k))\n            diff = neighbor - sample\n            random_scale = random.uniform(0, 1)\n            synthetic_sample = sample + random_scale * diff\n            synthetic_data.append(synthetic_sample)\n\n    return np.array(synthetic_data)\n\n\n# Main Function\ndef main(input_data, normalization_method, k_values, synthetic_sample_percentage):\n    # Normalize data based on user-selected method\n    if normalization_method == 'min_max':\n        data = min_max_normalization(input_data)\n    elif normalization_method == 'z_score':\n        data = z_score_normalization(input_data)\n    else:\n        raise ValueError(\"Invalid normalization method specified.\")\n\n    # Calculate total synthetic samples to generate for the whole dataset\n    total_synthetic_samples = int(synthetic_sample_percentage * len(data) / 100)\n    print(total_synthetic_samples)\n    synthetic_datasets = {}\n\n    # Generate synthetic data for each value of k\n    for k in k_values:\n        synthetic_data = generate_synthetic_samples(data, k, total_synthetic_samples)\n        synthetic_datasets[f\"synthetic_k_{k}\"] = synthetic_data\n\n    return synthetic_datasets\n\n\n# Command-line Interface\nif __name__ == \"__main__\":\n    parser = argparse.ArgumentParser(description=\"Generate Synthetic Zigbee Network Data\")\n    parser.add_argument(\"--data_file\", type=str, required=True, help=\"Path to input dataset (CSV format)\")\n    parser.add_argument(\"--normalization\", type=str, choices=['min_max', 'z_score'], required=True,\n                        help=\"Normalization method\")\n    parser.add_argument(\"--k_values\", nargs='+', type=int, default=[3, 5],\n                        help=\"List of k values for nearest neighbors\")\n    parser.add_argument(\"--synthetic_percentage\", type=int, default=100,\n                        help=\"Percentage of synthetic samples relative to the real dataset size\")\n\n    args = parser.parse_args()\n\n    # Load dataset\n    raw_data = np.genfromtxt(args.data_file, delimiter=',', skip_header=1, dtype=None, encoding=None)\n\n    # Convert data into numeric form\n    directions = np.array([encode_direction(row[0]) for row in raw_data])  # Encode Direction column\n    packet_sizes = np.array([row[3] for row in raw_data], dtype=float)  # Use Packet Size\n\n    # Combine direction and packet size into a single array for processing\n    input_data = np.column_stack((directions, packet_sizes))\n    input_data = input_data[:100,:]\n    print(input_data)\n    # Generate synthetic datasets\n    synthetic_datasets = main(input_data, args.normalization, args.k_values, args.synthetic_percentage)\n\n    # Decode direction values before saving\n    for key, synthetic_data in synthetic_datasets.items():\n        decoded_directions = [decode_direction(int(round(val[0]))) for val in\n                              synthetic_data]  # Decode back to original labels\n        output_data = np.column_stack((decoded_directions, synthetic_data[:, 1]))  # Combine with packet sizes\n\n        # Save synthetic datasets\n        np.savetxt(f\"{key}.csv\", output_data, delimiter=',', fmt='%s', header=\"Direction,Packet Size (bytes)\",\n                   comments=\"\")\n        print(f\"Saved {key}.csv\")\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Assignment_2/codes/k_nearest_neighbours.py b/Assignment_2/codes/k_nearest_neighbours.py
--- a/Assignment_2/codes/k_nearest_neighbours.py	(revision 8954cdcb18b85d90b5abca4334f5004d93e1cc89)
+++ b/Assignment_2/codes/k_nearest_neighbours.py	(date 1731417508806)
@@ -32,22 +32,28 @@
     for i, other_sample in enumerate(data):
         if not np.array_equal(sample, other_sample):
             distances.append((i, manhattan_distance(sample, other_sample)))
-    distances.sort(key=lambda x: x[1])  # Sort by distance
+    print(f"unsorted distences: {distances}")
+    distances.sort(key=lambda x: x[1])
+    print(f"sorted distences: {distances}")
     return [data[i] for i, _ in distances[:k]]
 
 
 # Synthetic Sample Generation
 def generate_synthetic_samples(data, k, total_synthetic_samples):
     synthetic_data = []
-    samples_to_generate = total_synthetic_samples // len(data)  # Evenly distribute synthetic samples across the dataset
-    remaining_samples = total_synthetic_samples % len(data)  # Handle any remaining samples
-    print(total_synthetic_samples, samples_to_generate)
     for i, sample in enumerate(data):
-         if i < remaining_samples:
-            neighbor = random.choice(find_k_nearest_neighbors(data, sample, k))
+         print(f"sample:{sample}")
+         if i < total_synthetic_samples:
+            k_neighbors = find_k_nearest_neighbors(data, sample, k)
+            neighbor = random.choice(k_neighbors)
+            print(f"k_neighbors:{k_neighbors} neighbor:{neighbor}")
             diff = neighbor - sample
+            print(f"diff:{diff}")
             random_scale = random.uniform(0, 1)
+            print(f"random_scale:{random_scale}")
+            print(f"random_scale * diff:{random_scale * diff}")
             synthetic_sample = sample + random_scale * diff
+            print(f"synthetic_sample:{synthetic_sample}")
             synthetic_data.append(synthetic_sample)
 
     return np.array(synthetic_data)
@@ -66,6 +72,7 @@
     # Calculate total synthetic samples to generate for the whole dataset
     total_synthetic_samples = int(synthetic_sample_percentage * len(data) / 100)
     print(total_synthetic_samples)
+    print(f"whole dataset: {data}")
     synthetic_datasets = {}
 
     # Generate synthetic data for each value of k
@@ -98,8 +105,8 @@
 
     # Combine direction and packet size into a single array for processing
     input_data = np.column_stack((directions, packet_sizes))
-    input_data = input_data[:100,:]
-    print(input_data)
+    input_data = input_data[:10,:]
+
     # Generate synthetic datasets
     synthetic_datasets = main(input_data, args.normalization, args.k_values, args.synthetic_percentage)
 
Index: Assignment_2/codes/convert_to_csv.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import pyshark\nimport csv\n\n\n# Function to extract relevant information from Zigbee packets\ndef extract_zigbee_data(pcap_file, output_csv):\n    # Open the pcap file using pyshark\n    capture = pyshark.FileCapture(pcap_file, display_filter=\"zbee_nwk\")\n\n    # List to store the results\n    data = []\n    # Iterate over all packets\n    for packet in capture:\n        # Check if the packet has Zigbee data and extract necessary information\n        print(packet.ZBEE_NWK)\n        # Extract the source and destination MAC addresses\n        source_mac = packet.ZBEE_NWK.src\n        destination_mac = packet.ZBEE_NWK.dst\n\n        # Determine the direction (send or receive)\n        # Here, we assume \"send\" is when the source is the local device, and \"receive\" is when it's the opposite.\n        direction = \"send\" if source_mac < destination_mac else \"receive\"\n\n        # Extract the size of the Zigbee packet (total length including headers)\n        packet_size = int(packet.length)\n\n        # Append the extracted data to the list\n        data.append([direction, source_mac, destination_mac, packet_size])\n\n    # Write the extracted data into a CSV file\n    with open(output_csv, mode='w', newline='') as f:\n        writer = csv.writer(f)\n        writer.writerow([\"Direction\", \"Source\", \"Destination\", \"Packet Size (bytes)\"])  # Header\n        writer.writerows(data)\n\n    print(f\"Data has been successfully written to {output_csv}\")\n\n\n# Example usage\npcap_file = '/Users/montasermajid/Documents/Btu Cottbus/Smart-home/Assignment_2/dataset/pcap/scenario_1_ledvance_to_coordinator.pcapng'\noutput_csv = '../dataset/csv/output_file.csv'\nextract_zigbee_data(pcap_file, output_csv)\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Assignment_2/codes/convert_to_csv.py b/Assignment_2/codes/convert_to_csv.py
--- a/Assignment_2/codes/convert_to_csv.py	(revision 8954cdcb18b85d90b5abca4334f5004d93e1cc89)
+++ b/Assignment_2/codes/convert_to_csv.py	(date 1731418669895)
@@ -1,42 +1,51 @@
 import pyshark
 import csv
+from collections import defaultdict
 
 
-# Function to extract relevant information from Zigbee packets
-def extract_zigbee_data(pcap_file, output_csv):
+# Function to extract relevant information from Zigbee packets and group by device pairs
+def extract_zigbee_data(pcap_file, output_directory):
     # Open the pcap file using pyshark
     capture = pyshark.FileCapture(pcap_file, display_filter="zbee_nwk")
 
-    # List to store the results
-    data = []
+    # Dictionary to store data for each (source, destination) pair
+    data_by_pair = defaultdict(list)
+
     # Iterate over all packets
     for packet in capture:
-        # Check if the packet has Zigbee data and extract necessary information
-        print(packet.ZBEE_NWK)
-        # Extract the source and destination MAC addresses
-        source_mac = packet.ZBEE_NWK.src
-        destination_mac = packet.ZBEE_NWK.dst
+        # Ensure the packet has Zigbee data
+        if hasattr(packet, "ZBEE_NWK"):
+            # Extract the source and destination MAC addresses
+            source_mac = packet.ZBEE_NWK.src
+            destination_mac = packet.ZBEE_NWK.dst
 
-        # Determine the direction (send or receive)
-        # Here, we assume "send" is when the source is the local device, and "receive" is when it's the opposite.
-        direction = "send" if source_mac < destination_mac else "receive"
+            # Determine the direction (send or receive)
+            if source_mac == "0x0000":
+                direction = "send"  # If source is 0x0000, it's a send (from 0x0000 to another device)
+            else:
+                direction = "receive"  # Otherwise, it's a receive (from another device to 0x0000)
 
-        # Extract the size of the Zigbee packet (total length including headers)
-        packet_size = int(packet.length)
+            # Extract the size of the Zigbee packet (total length including headers)
+            packet_size = int(packet.length)
 
-        # Append the extracted data to the list
-        data.append([direction, source_mac, destination_mac, packet_size])
+            # Append the extracted data to the dictionary for the device pair
+            data_by_pair[(source_mac, destination_mac)].append([direction, source_mac, destination_mac, packet_size])
 
-    # Write the extracted data into a CSV file
-    with open(output_csv, mode='w', newline='') as f:
-        writer = csv.writer(f)
-        writer.writerow(["Direction", "Source", "Destination", "Packet Size (bytes)"])  # Header
-        writer.writerows(data)
+    # Write the extracted data into separate CSV files for each (source, destination) pair
+    for (source_mac, destination_mac), data in data_by_pair.items():
+        # Define the output file path for each pair (using source and destination MAC addresses in the filename)
+        output_csv = f"{output_directory}/data_{source_mac}_{destination_mac}.csv"
+
+        # Write the data into the CSV file
+        with open(output_csv, mode='w', newline='') as f:
+            writer = csv.writer(f)
+            writer.writerow(["Direction", "Source", "Destination", "Packet Size (bytes)"])  # Header
+            writer.writerows(data)
 
-    print(f"Data has been successfully written to {output_csv}")
+        print(f"Data for pair {source_mac} <-> {destination_mac} has been written to {output_csv}")
 
 
 # Example usage
-pcap_file = '/Users/montasermajid/Documents/Btu Cottbus/Smart-home/Assignment_2/dataset/pcap/scenario_1_ledvance_to_coordinator.pcapng'
-output_csv = '../dataset/csv/output_file.csv'
-extract_zigbee_data(pcap_file, output_csv)
+pcap_file = '/path/to/your/pcapfile.pcapng'  # Path to your input pcap file
+output_directory = '/path/to/output/directory'  # Path to the output directory where CSVs will be saved
+extract_zigbee_data(pcap_file, output_directory)
